import os
import json
import pysocrata
import numpy as np
from tqdm import tqdm


# import datafy
import sys; sys.path.insert(0, "../../limited-requests")
import limited_requests

DOMAIN = "data.cityofnewyork.us"
FILE_SLUG = "nyc"

# First check to see whether or not a geospatial.json file already exists. We won't recreate the file if it already
# exists. This means that:
# 1. To regenerate the information from scratch, the file must first be deleted.
# 2. Manual edits to the glossary will be preserved (this is a behavior that we want) and considered by the second part
#    of this script.
preexisting = os.path.isfile("../../../data/" + FILE_SLUG + "/glossaries/geospatial.json")


# If not, build out an initial list.
if not preexisting:
    # Obtain NYC open data portal credentials.
    with open("../../../auth/nyc-open-data.json", "r") as f:
        nyc_auth = json.load(f)

    # Use pysocrata to fetch portal metadata.
    nyc_datasets = pysocrata.get_datasets(**nyc_auth)
    nyc_datasets = [d for d in nyc_datasets if d['resource']['type'] != 'story']  # stories excluded manually

    # Get geospatial datasets.
    nyc_types = [d['resource']['type'] for d in nyc_datasets]
    volcab_map = {'dataset': 'table', 'href': 'link', 'map': 'geospatial dataset', 'file': 'blob'}
    nyc_types = list(map(lambda d: volcab_map[d], nyc_types))
    nyc_endpoints = [d['resource']['id'] for d in nyc_datasets]
    geospatial_indices = np.nonzero([t == 'geospatial dataset' for t in nyc_types])
    geospatial_endpoints = np.array(nyc_endpoints)[geospatial_indices]
    geospatial_datasets = np.array(nyc_datasets)[geospatial_indices]

    # Build the data representation.
    datasets = []
    for dataset in geospatial_datasets:
        endpoint = dataset['resource']['id']
        slug = "https://" + DOMAIN + "/api/geospatial/" + endpoint + "?method=export&format=GeoJSON"
        datasets.append(
            {
                'endpoint': endpoint,
                'resource': slug,
                'dataset': '.',
                'type': 'geojson',
                'rows': '?',
                'columns': '?',
                'filesize': '?',
                'flags': ''
             }
        )

    # Write to the file.
    with open("../../../data/" + FILE_SLUG + "/glossaries/geospatial.json", "w") as fp:
        json.dump(datasets, fp, indent=4)

    del datasets


# At this point we know that the file exists. But its contents may not contain the row and column size information that
# we need, because if it was just regenerated by the loop above that stuff will have been populated simply with "?" so
# far.

# Begin by loading in the data that we have.
with open("../../../data/" + FILE_SLUG + "/glossaries/geospatial.json", "r") as fp:
    datasets = json.loads(fp.read())
# datasets = [
#     {
#         "dataset": ".",
#         "rows": "?",
#         "columns": "?",
#         "flags": "",
#         "resource": "https://data.cityofnewyork.us/api/geospatial/u6su-4fpt?method=export&format=GeoJSON",
#         "type": "geojson",
#         "endpoint": "u6su-4fpt",
#         "filesize": 2768
#     },
#     {
#         "dataset": ".",
#         "rows": "?",
#         "columns": "?",
#         "flags": "",
#         "resource": "https://data.cityofnewyork.us/api/geospatial/fw3w-apxs?method=export&format=GeoJSON",
#         "type": "geojson",
#         "endpoint": "fw3w-apxs",
#         "filesize": 1216
#     },
#     {
#         "dataset": ".",
#         "rows": "?",
#         "columns": 2,
#         "flags": "",
#         "resource": "https://data.cityofnewyork.us/api/geospatial/xiyt-f6tz?method=export&format=GeoJSON",
#         "type": "geojson",
#         "endpoint": "xiyt-f6tz",
#         "filesize": 320
#     },
#     {
#         "dataset": ".",
#         "rows": "?",
#         "columns": 2,
#         "flags": "",
#         "resource": "https://data.cityofnewyork.us/api/geospatial/bpt7-i8t8?method=export&format=GeoJSON",
#         "type": "geojson",
#         "endpoint": "bpt7-i8t8",
#         "filesize": 704
#     },
#     {
#         "dataset": ".",
#         "rows": "?",
#         "columns": 2,
#         "flags": "",
#         "resource": "https://data.cityofnewyork.us/api/geospatial/58k2-kgtb?method=export&format=GeoJSON",
#         "type": "geojson",
#         "endpoint": "58k2-kgtb",
#         "filesize": 2928
#     },
#     {
#         "dataset": ".",
#         "rows": "?",
#         "columns": 2,
#         "flags": "",
#         "resource": "https://data.cityofnewyork.us/api/geospatial/7b32-6xny?method=export&format=GeoJSON",
#         "type": "geojson",
#         "endpoint": "7b32-6xny",
#         "filesize": 5248
#     }
# ]


# Get the datasets we need to extract things from.
datasets_needing_extraction = [d for d in datasets\
                               if (d['filesize'] == "?")]
indices = [i for i, d in enumerate(datasets)\
           if (d['filesize'] == "?")]
uris = [d['resource'] for d in datasets_needing_extraction]
endpoints = [d['endpoint'] for d in datasets_needing_extraction]


# Create a q for managing jobs.
q = limited_requests.q()
timeout = 60


# Run the process.
import pdb; pdb.set_trace()
try:
    for dataset, i, uri in tqdm(zip(datasets_needing_extraction, indices, uris)):
        sizing = limited_requests.limited_get(uri, q, timeout=timeout)
        if sizing:  # If successful.
            datasets[i]['rows'] = sizing['rows']
            datasets[i]['columns'] = sizing['columns']
            datasets[i]['filesize'] = sizing['filesize']
        else:  # If not successful.
            datasets[i]['filesize'] = ">{0}s".format(timeout)
except Exception as e:
    import pdb; pdb.set_trace()
    print("HELLO")
finally:
    # Whether we succeeded or got caught on a fatal error, in either case save the output to file before exiting.
    with open("../../../data/" + FILE_SLUG + "/glossaries/geospatial.json", "w") as fp:
        json.dump(datasets, fp, indent=4)